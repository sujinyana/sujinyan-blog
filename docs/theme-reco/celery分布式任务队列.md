---
title: celery异步任务队列 重复消费 消息丢失问题以及生产者消费者
date: 2017-10-16 16:15:44
tags: [celery,生产者,消费者]
---

Celery分布式任务队列，同步写法实现异步消息队列（也可以推送消息）

有两个任务模块： 异步任务（并发发往消息队列）

​				定时任务（定时将任务发往消息队列）

架构由三部分组成：消息中间件（message broker）：支持RabbitMQ、Redis、Mongodb、Memcached

​				  任务执行单元（worker）

​				  任务执行结果存储（Backend）:存在方式RabbitMQ、Redis、Memcached

Celery建议的消息队列是RabbitMQ，为了简单可以都使用 redis或者rabbitmq

redis的作为消息中间件可谓是差强人意，功能和性能上都不如RabbitMQ，消息中间件使用RabbitMQ来实现异步发邮件，监控任务队列。

任务重复执行：

celery执行定时任务的时候遇到了重复执行的问题，当时是用redis做broker和backend。

解决方法是在每次定时任务执行完就在redis中写入一个唯一的key对应一个时间戳，当下次任务执行前去获取redis中的这个key对应的value值，和当前的时间做比较，当满足我们的定时频率要求时才执行，这样保证了同一个任务在规定的时间内只会执行一次。

 

消息丢失问题：

rabbitmq和redis都可以持久化，并且工作的很良好，我维护过的一个rabbitmq消息队列运行一年左右时间也没有出现过丢消息之类的问题，并且还可以做热备如果你的订单量不大，或者说，目前这个惯用的轮询的方式已经工作的非常良好，那也不失为一个好方案。多引入一个rabbitmq或者redis，一方面，你程序的配置会变得更加复杂（意味着上线也会多步骤，比如要检查你消息队列中的消息是否要延后处理），另一方面，运维需要多一个东西要关注和监控，这是实实在在增加的成本

能在性能，开发便利性还有运维便利性之间做一个良好的平衡，才是一个好的技术方案



## 生产者消费者模型

生产者-消费者模式是一个十分经典的多线程并发协作的模式，弄懂生产者-消费者问题能够让我们对并发编程的理解加深。所谓生产者-消费者问题，实际上主要是包含了两类线程，一种是生产者线程用于生产数据，另一种是消费者线程用于消费数据，为了解耦生产者和消费者的关系，通常会采用共享的数据区域，就像是一个仓库，生产者生产数据之后直接放置在共享数据区中，并不需要关心消费者的行为；而消费者只需要从共享数据区中去获取数据，就不再需要关心生产者的行为。但是，这个共享数据区域中应该具备这样的线程间并发协作的功能：

如果共享数据区已满的话，阻塞生产者继续生产数据放置入内； 如果共享数据区为空的话，阻塞消费者继续消费数据；

生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。

![img](img/sx.png)